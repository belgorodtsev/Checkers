# Теоретическая часть 

## Условие задачи

Реализовать программу для игры в шашки, которая предлагает лучший ход для позиции, переданной во входных данных.

## Подходы к решению задачи

Идеей решения данной задачи, в первую очередь, является выбор оптимальной стратегии поиска лучшего хода.
Также необходимо уточнить правила игры которым будет подчиняться программа.

*Правила игры:*
- Игра ведётся на доске 8х8 клеток, только на черных ячейках
- Бить можно произвольное количество шашек в любых направлениях
- Простые шашки ходят только вперёд
- Простая шашка может срубить назад
- Дамка ходит на любое число полей в любую сторону (реализации с дамкой пока нет)
- Проигрывает тот, у кого не остается фигур, либо ходов
- Шашка снимается с поля после боя (можно перефразировать так: одну шашки нельзя срубить дважды за один ход)
- Бить обязательно
- Шашка превращается в дамку, достигнув восьмой (для белых) или первой (для черных) линии доски
- Если шашка во время боя проходит через дамочное поле, то она превращается в дамку и следующие бои (если они возможны) совершает уже как дамка

### Формальная постановка задачи

С использованием языка C++ реализовать программу для игры в шашки, которая предлагает лучший ход для позиции, переданной во входных данных.

Реализация программы будет включать следующие этапы: 
1. Определение формата входных и выходных данных;
2. Выбор и реализация способа хранения шахматной доски;
3. Выбор и реализация алгортма поиска лучшего хода для заданной позиции;

Выделяют два типа стратегий поиска лучшего хода:
- тип А – перебор всех возможных ходов на фиксированную глубину и использование в конце оценочной функции; 
- тип В – только выборочное расширение определённых строк, используя накопленные знания игры, чтобы «подрезать» ненужные ветви дерева решений.

Основными алгоритмами для оценки позиции в антагонистических играх являются: MiniMax (тип А по Шеннону), NegaMax (тип А), alpha-beta отсечение (тип В), метод Монте-Карло (тип В).
Практически все игры можно представить в виде т.н. деревьев решений, где каждый узел будет представлять собой один шаг решения задачи (ход в игре), ветвь в дереве соответствует решению, которое ведёт к более полному решению, листы представляют собой окончательное решение (итоговые позиции). Наша цель – найти в дереве лучший путь от корня до листа.

Эти алгоритмы опираются на эвристику, которая необходима для оценки вероятности победы того или иного игрока, для какого-либо состояния. Дополнительная задача будет состоять в том, чтобы построить эвристическую оценочную функцию, которая достаточно быстро и точно, в выбраной метрике, сможет указать оценку вероятности победы конкретного игрока для конкретного расположения фигур, не опираясь на то, каким образом игроки к этому состоянию пришли.

### Алгоритм MiniMax

В корне дерева мы ищем лучшую последующую позицию для игрока, которому принадлежит очередь хода; на следующем уровне, мы ищем лучшую последующую позицию с точки зрения противника, и так далее. Поиск по шахматному дереву - чередование между максимизированием и минимизированием оценок позиций в дереве, что часто сокращенно называют минимаксингом (minimaxing).

### Алгоритм NegaMax

Алгоритм аналогичный MiniMax, только чтобы устранить различие между собственной позицией и позицией противника, значение позиции всегда оценивается с точки зрения игрока, которому принадлежит ход, т.е. беря оценку позиции противником с противоположным знаком, что называется негамаксингом (negamaxing).
Число позиций, которое должно быть просмотрено этими алгоритмами - $W^D$, где $W$ - ширина дерева (среднее количество ходов, возможных в каждой позиции) и $D$ - глубина дерева.

Этот метод чрезвычайно неэффективен и не позволяет достичь большой глубины.

### Алгоритм Alpha-Beta search

Альфа-бета отсечение основано на той идее, что анализ некоторых ходов можно прекратить досрочно, игнорируя результат их показаний. Альфа-бета отсечение является оптимизирующей модификацией алгоритвов MiniMax и NegaMax. Альфа-бета относится к классу методов ветвей и границ.

Грубо говоря, оптимизация вводит две дополнительные переменные alpha и beta, где alpha — текущее максимальное значение, меньше которого игрок максимизации никогда не выберет, а beta — текущее минимальное значение, больше которого игрок минимазации никогда не выберет. Изначально они устанавливаются в -∞, +∞ соответственно, и по мере получения оценок модифицируются:

- alpha = max(alpha, $f(Vi)$); для уровня максимизации.
- beta = min(beta, $f(Vi)$); для уровня минимизации.

Где $f(Vi)$ — расчетная оценка вероятности победы для узла дерева решений Vi.

Как только условие alpha > beta станет верным, что означает конфликт ожиданий, мы прерываем анализ узлов дерева и возвращаем последнюю полученную оценку этого уровня.

*Пример:*
![alt-текст](https://upload.wikimedia.org/wikipedia/commons/9/91/AB_pruning.svg)

Эти отсечения полностью безопасны (корректны), потому что они гарантируют, что отсекаемая часть дерева хуже чем основной вариант. Самый большой выигрыш будет достигнут, когда на каждом уровне дерева лучшая последующая позиция будет рассмотрена сначала, т.к. эта позиция будет частью основного варианта (который мы хотим обнаружить как можно раньше) или это заставит отсечению произойти как можно раньше.
При оптимальных обстоятельствах перебор с альфа-бета отсечением должен просмотреть $W^{((D+1)/2)} + W^{(D/2)} - 1$ позицию. Это намного меньше чем минимакс, но все еще экспоненциально.

Данное отсечение позволяет достигать примерно вдвое большей глубины за то же самое время. Большее количество позиций будет просмотрено в том случае, если при переборе не совершается упорядочение ходов.

### Метод Монте-Карло 

Задача этого алгоритма — выбрать наиболее выигрышный вариант, анализируя сыгранные и удачные ходы в игре. Программа перебирают случайным образом несколько миллионов игр, которые могут быть сыграны из текущего положения. Причём каждая игра проигрывается до конца, программу вычисляет выгодность хода, единственно ограничение — следование правилам.
Проиграв до конца миллионы партий, программа получает некоторую статистику о вероятности выигрыша после первого хода. По этой статистике программа считает вероятность выиграша для некоторого хода. Далее программа просто выбирает ход с наибольшей вероятностью выигрыша и повторяет алгоритм. В итоге программа делает ход, который с наибольшей вероятностью ведёт к победе. 

## Выбор алгоритма

Был выбран алгоритм Alpha-Beta search на основе MiniMax, потому что он больше подходит для поставленной задачи. Данный алгоритм более эффективен в отличие от MiniMax и NegaMax, т.к. позволяет прекратить анализ некоторых ходов досрочно.
Метод Монте-Карло менее эффективен для шашек и шахмат, чем выбранный алгоритм. Проблема в том, что при реализации метода Монте-Карло встречаются "ловушки поиска" - некоторые хорошие ходы (жертвы и т.п.) представляются плохими до тех пор, пока не будет найдена специфическая последовательность ходов. Эти "ловушки" довольно частое явление, и известные реализации метода сталкиваются с проблемой - для обнаружения "ловушки" необходимо гораздо больше итераций, чем минимаксу. Метод Монте-Карло более применим к таким играм как сёга и го.
 
