# Запуск программы

## Компиляция

Для рассчёта лучшего хода нужно создать объект класса `Game(const std::string& in, const std::string& out)`, в параметы конструктора необходимо передать путь к файлам с входными данными и выходными (первый и второй аргументы командной строки).
на следующем шаге, нужно вызвать метод `calculateBestMove(const char palyer, const size_t depth)`, первым параметром которого является игрок, для которого мы рассчитываем лучший ход, третий аргумент командной строки (WHITE или 'w' - для белых,
BLACK или 'b' - для черных), второй параметр глубина рассчёта, четвёртый аргумент командной строки. Перед сохранением результата необходимо сделать лучший ход, вызвав метод `makeBestMove()`, а затем `saveGame()`.

*Пример:*
```
#include <Game.hpp>

int main(int argc, char* argv[]) {
    Game game(argv[1], argv[2]);
    game.calculateBestMove(argv[3], argv[4]);
    game.makeBestMove();
    game.saveGame();
    return 0;
}
```

Помимо рассчёта лучшего хода, есть возможность полноценной игры в шашки. Для этого необходимо создать объект класса `Game` используя конструктор по умолчанию, при этом игра будет начинаться сначала. Так же есть возможность начать игру 
на доске, путь к файлу с которой будет передан в конструктор объекта (также как и при рассчёте лучшего хода). Для начала игры вызываем метод `play(const char color, size_t depth)`, первый параметр - цвет за который будем играть, второй- глубина 
просчёта ходов противника.

*Пример:*
```
#include <Game.hpp>

int main(int argc, char* argv[]) {
    Game game;
    game.play(WHITE, 5);
    return 0;
}
```

## Выполнение

Для рассчета лучшего хода необходимо выполнить:
```
./Project/Checkers/Debug/Checkers.exe in.txt out.txt color depth
```
Где in.txt out.txt - пути входного и выходного файла соответственно, color - цвет, для которого рассчитывается лучший ход, depth - глубина рассчёта. Если цвет и глубина введены некорректоно, то ход по умолчанию будет рассчитан для белых с глубиной 8.

## Формат входных данных

Входные данные задаются в текстовом файле в следующем формате:

```
  A B C D E F G H
1 _ b _ b _ b _ b
2 b _ b _ b _ b _
3 _ b _ b _ b _ b
4 0 _ 0 _ 0 _ 0 _
5 _ 0 _ 0 _ 0 _ 0
6 w _ w _ w _ w _
7 _ w _ w _ w _ w
8 w _ w _ w _ w _
```

Первые восемь строк задают шахматную доску. Первая строка содержит данные клеток A1 - H1, вторая A2 - H2 и т.д. Строка может содержать шесть символов разделённые пробелами(для сохранения видимости диагоналей) 'w' - белая фигура, 'b' - черная фигура, 'W' - белая дамка, 'B' - чёрная дамка, '0' - если фигура отсутствует, символом '_' обозначены диагонали по которым фигуры не могут ходить.  

## Формат выходных данных

Формат выходных данных аналогичен формату входных, за исключением того, что, на шахматной доске будет сделан лучший ход который мы получили в процессе расчёта, а следующая строка всегда будет содержать информацию какой игрок ходил и координату клетки этого хода в виде `startPos->endPos`. Также, при выиграше одного из игроков будет строка, информирующая об этом.

*Например:*

```
  A B C D E F G H
1 _ 0 _ 0 _ 0 _ 0
2 0 _ 0 _ 0 _ 0 _
3 _ 0 _ 0 _ W _ 0
4 0 _ 0 _ 0 _ 0 _
5 _ w _ 0 _ 0 _ 0
6 0 _ 0 _ 0 _ 0 _
7 _ 0 _ 0 _ 0 _ 0
8 0 _ 0 _ 0 _ 0 _
White`s move: B7->F3
White won. Game over!
```

