# Описание программы

## Краткое описание логики

При создании объекта класса `Game`, создается объект класса `Board`, при создании которого вызывается метод `parsing` который считывает входные 
данные, проверяет их на валидность с помощью методов из файла `parsUtils` и записывает в соответсвующую мапу.

Затем вызывается метод `calculateBestMove(const char color, size_t depth)` класса `Game`, который вызывает такой же инкапсулированный метод класса `Board`. 
Сначала устанавливаем цвет игрока, для которого считаем `setMoveColor(color)`, а затем начинается использование основного алгоритма:
вызывается метод `minimaxRoot(depth)`, который возвращает список ходов всех фигур с их оценкой. В этом с помощью метода `findAndSetBestPos`
списке ищется и инициализируется лучший ход, сначала ищется бой с наилучшим счётом, если боя, то ход с наилучшим счётом.

Функция `minimaxRoot(depth)` работает следующим образом:
+ генерируется список всех возможных пешек на доске методом `generateListPieces(color)`;
+ для каждой пешки из этого списка генерируются всевозможные ходы методом `generateAllMoves(piece, color)`;
+ для каждого хода из этого списка вызывается метод `makeMove(piece, move)`, затем считается значение полученное 
вызовом алгоритма минимакса `minimax(color, depth, alpha, beta, isMaximisingPlayer)`, затем ход возвращается назад `revokeMove()`.
И если полученное значение больше максимального, этот ход становится лучшим;
+ лучший ход добавляется в список фигур.

Функция `minimax(color, depth, alpha, beta, isMaximisingPlayer)` работает следующим образом:
+ если глубина просчёта равна нулю, возвращаем оценку состояни доски `evaluate()`;
+ генерируется список всех возможных пешек на доске методом `generateListPieces(color)`, т.е для чёрны - false, для белых - true;
+ затем, в зависимости от флага isMaximisingPlayer максимизируем или минимизируем:
	* если isMaximisingPlayer: для каждой пешки из этого списка получаем ход getMove(moves) и вызывается метод `makeMove(piece, move)`, 
	  затем максимальное значение `bestScore` выбирается из предидущего значения и значения полученного рекурсивным вызовом минимакса 
	  `bestScore = max(bestScore, minimax(!color, depth - 1, alpha, beta, !isMaximisingPlayer))`, затем ход возвращается назад `revokeMove()`.
	  `alpha = max(alpha, bestScore)`, если `beta <= alpha ` возвращаем bestScore;
	* если !isMaximisingPlayer: для каждой пешки из этого списка получаем ход getMove(moves) и вызывается метод `makeMove(piece, move)`, 
	  затем минимальное значение `bestScore` выбирается из предидущего значения и значения полученного рекурсивным вызовом минимакса 
	  `bestScore = min(bestScore, minimax(!color, depth - 1, alpha, beta, !isMaximisingPlayer))`, затем ход возвращается назад `revokeMove()`.
	  `beta = min(beta, bestScore)`, если `beta <= alpha ` возвращаем bestScore;
+ возвращаем bestScore;

Функция `evaluate()` следующим образом:
Используется самая простая эвристика, работающая на всех этапах игры одинаково. У нас есть матрица оценки каждой клетки доски:
```
const int _heuristic[8][8] =
        { {4, 4, 4, 4, 4, 4, 4, 4},
        {4, 3, 3, 3, 3, 3, 3, 4},
        {4, 3, 2, 2, 2, 2, 3, 4},
        {4, 3, 2, 1, 1, 2, 3, 4},
        {4, 3, 2, 1, 1, 2, 3, 4},
        {4, 3, 2, 2, 2, 2, 3, 4},
        {4, 3, 3, 3, 3, 3, 3, 4},
        {4, 4, 4, 4, 4, 4, 4, 4} };
```
Считаем сумму клеток для каждого цвета фигур, если в клетке дамка умножаем содержимое на 2, и возвращаем разность счёта (цвет_для_которого_считаем - цвет_противника).

## Использованные структуры данных

Для хранения доски использована структура `std::map<pos, Cell>`, т.к нужно быстрое обращение к доске (красночерное дерево), ключом которой является пара `pos = std::pair<size_t, size_t>` координата 
клетки на доске, а значением - объект класса Cell. Для данной цели не была использована хеш таблица, т.к. std::hash не хеширует пару, можно было бы написать свою хэш-функцию, 
и переопределить свой контейнер,но это плохое решение. 

Для хранения ходов при которых шашка становится дамкой использована мапа, т.к нужно быстрое обращение к произвоьному ходу`std::map<posMove, bool>`, ключём которой 
является `posMove = std::pair<pos, pos>`.

Для хранения позиций ходов, побитых пешек и тд. использован список `std::list<std::pair<pos, Cell>>`, так как добавление и удаление в нём происходит за константу, а индексное 
обращение к элементу и поиск(в одном методе) используются очень редко.

Для хранения истории сделанных ходов и списка побитых фигур используется стек std::stack, т. к. необходимо сохранять сделанный ход в методе `makeMove` в алгоритме 
минимакса, чтобы при из рекурсии в методе `revokeMove` вернуть сделанный ход назад.

## Оценка сложности 

Если оценивать сверху, то максимальная сложность у алгоритма минимакса. Для одной пешки необходимо просмотреть O(M^D), где M - среднее колличество ходов
в позиции, D - глубина просчёта. Но при оптимальных обстоятельствах перебор с альфа-бетой отсечением должен просмотреть O(M^((D+1)/2) + M^(D/2) - 1). Это
меньше чем при обычном минимаксе, но всё ещё экспоненциально.

## Оценка использования памяти

Мапа для хранения доски использует O(a) памяти, где a - колличество клеток. 
Мапа для хранения ходов в которые шашка становится дамкой использует O(b) памяти, где b - колличество таких ходов. 
Два стека записи истории сделанных ходов и листа побитых шашек при ходе используют O(c) и O(d*e), с колличество сделанных ходов, d - колличество списков, e - позиций в списке.
При выполнении функйии минимакса используются: список пешек O(k), список ходов этой пешки O(m), стек вызывов при рекурсии O(s).
Тогда общая сложность по памяти O(a + b + c + d*e + k*m + s). Наверное :-)
